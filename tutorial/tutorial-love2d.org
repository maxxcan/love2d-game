#+TITLE: tutorial-love2d
#+AUTHOR: Patricio Martínez 
#+DATE: <2018-04-20 vie>
#+EMAIL: maxxcan@disroot.org

* Introducción 

Este tutorial es una traducción casi literal de un tutorial de introducción de Love2D. La traducción la realizo tanto para aprender
como para que haya más documentación en español sobre este framework. 

El original está en [[http://sheepolution.com/learn/book/contents][Sheepolution]]

Este tutorial está escrito para personas sin experiencia en programación. Así que si no tienes ninguna experiencia en programación, espero que este tutorial también ayude con tu formación en ese área. 

* Instalación 

Los capítulos 2 y 3 se pueden realizar sin necesidad de instalar nada. Puedes usar [[https://repl.it/languages/lua][repl.it]] como alternativa. 

** Love 

Para instalar en todo caso Love, en nuestro ordenador tenemos que ir a [[https://www.love2d.org/][love2d.org]]. Una vez allí podemos elegir la versión que necesitemos según nuestra computadora y sistema operativo 

En mi caso uso Archlinux con lo que el framework nos lo podemos descargar directamente desde AUR con el gestor de paquetes yaourt. Tan solo tenemos que ejecutar el comando: 

: yaourt -S love 

** Editor 

Para este tutorial podemos elegir el eband waditor o IDE que nos apetezca. Yo en mi caso usaré Emacs que además de soporte para Lua (el lenguaje de este framework) hay un pequeño modo para love2d que nos ayuda. 

El autor del artículo original recomienda *Zerobrane* que es un IDE con muchas características útiles para trabajar con Lua. Puedes descargarlo desde [[https://studio.zerobrane.com/support][aquí.]] 

Si posees Archlinux también puedes descargarlo usando *yaourt* 


Una vez tengamos abierto nuestro editor o IDE preferido lo abrimos y creamos un fichero con el siguiente código:

#+BEGIN_SRC lua
  function love.draw()
    love.graphics.print("Hola Mundo!", 100, 100)
  end 

#+END_SRC

Y lo salvamos con el nombre de *main.lua* 

* Variables 

¿Qué es a + b?

Una variable es un símbolo que apunta a un valor. Para ello tendremos que indicarle cual es el valor al que apunta. 

Si queremos saber cual es la suma de a + b entonces tendremos que asignarle valores. Para hacer esto escribimos:

: a = 5
: b = 3
: print(a + b)

-- Resultado: 8

La palabra que usemos para guardar los valores puede ser cualquiera.

: sheep = 3
: test = 20
: PANTS = 1024
: asdfghjkl = 42 

La variables son sensibles a mayúsculas y minúsculas. Esto significa que no es lo mismo la variable a que la variable A. Por ejemplo.

: sheep = 3 
: SHEEP = 10
: SHeEp = 200

Estas son 3 variables distintas

A la hora de asignar variables podemos hacer algo más que asignar valores. 

: a = 20 - 10 -- Sustracción
: b = 20 * 10 -- Multiplicación
: c = 20 / 10 -- División
: d = 20 ^ 10 -- Exponenciación 

Para los números con decimales usamos el punto. 

: a = 10.4
: b = 2.63
: c = 0.1
: pi = 3.141592

* Cadenas de texto

Una variable también puede guardar un texto.
: texto = "Hola Mundo"

Podemos conectar cadenas de caracteres usando dos puntos (..)

: nombre = "Daniel"
: edad = "22"
: texto = "Hola, mi nombre es " .. nombre .. ", y tengo la edad de " .. "años"
: print(texto)

Salida -- "Hola, mi nombre es Daniel y tengo la edad de 22 años"

** Reglas nombre variables 

Hay unas pocas reglas para nombrar a las variables. Primero de todo, la variable puede tener un número en ella, pero no al principio. 

: test8 -- Bien
: te8st -- Bien
: 8test -- Mal

El nombre de la variable tampoco puede incluir caracteres especiales tales como @#$%^&* 

Y finalmente, el nombre de la variable no puede ser una palabra clave. Una palabra clave es una palabra que el lenguaje de ordenador usa. Aquí tenemos una lista de palabras clave: 

| and    | break  | do   | else     | elseif |
| end    | false  | for  | function | if     |
| in     | local  | nil  | not      | or     |
| repeat | return | then | true     | until  |
| while  |        |      |          |        |

* Funciones 

Con las funciones nosotros guardamos trozos de código. Esto nos permite ejecutar este código en donde nosotros queramos. 

Hay dos formas de crear una función: 

#+BEGIN_SRC lua
  ejemplo = function ()
    print("Hola Mundo!")
  end
#+END_SRC

Y la forma más común:

#+BEGIN_SRC lua
  function ejemplo()
    print("Hola Mundo!")
  end
#+END_SRC

Primero empezamos usando la palabra clave *function*, seguido del nombre de la función. Una función es un tipo de varialbe, así que las mismas reglas que aplicamos cuando nombramos uan variable se aplica para las unciones. Después del nombre ponemos unos paréntesis. Ahora podemos empezar a escribgir el código que queremos poner dentro de la función. 

Una vez hecho esto, tenemos que escribir el nombre de la función para obtener el resultado. Esto es lo que llamamos *llamada a una función* 

** Parámetros 

Veamos el siguiente código 

#+BEGIN_SRC lua
  function ejemplo(num)
    print("Me gusta el número " .. num)
  end 
#+END_SRC

: ejemplo(15)
: ejemplo(2)
: ejemplo(100)

: -- Salida:
: -- "Me gusta el número 15"
: -- "Me gusta el número 2"
: -- "Me gusta el número 100"

Dentro del paréntesis de la función nosotros podmeos poner lo que llamamos *parámetros*. Los parámetros son variables temporales que solo existen dentro de la función. En este caso usamos el parámetro num. Ahora podemos usar num como cualquier otra variable.

** Return 

Las funciones puede devolver un valor, el cual podemos guardarlo en una variable, por ejemplo. Podemos devolver un valor usando la palabra clave *return* 

#+BEGIN_SRC lua
  function dameCinco()
    return 5
  end

a = dameCinco()
print(a)

#+END_SRC

: -- Salida: 5

Vemos el valor que devuelve dameCinco gracias a *return* 

Otro ejemplo: 

#+BEGIN_SRC lua
  -- Múltiples argumentos y parámetros separados por comas
  function sum(a, b)
    return a + b
  end

  print(sum(200, 95))
#+END_SRC

: -- Salida:
: -- 34
: -- 295

Nuestra función sum devuelve la suma de a y de b.

** ¿Por qué las funciones?

Usando funciones nosotros no tenemos que repetir cierto código una y otra vez de nuevo. Podemos simplemente hacer llamadas a la función que necesitemos. Esto es grande, porque nosotros podemos cambiar una función en el futuro, y no tener la necesidad de tener que cambiarla en todas los lugares donde la hemos puesto. 
* Love 
** Qué es Love 

Love es lo que llamamos un *framework* o marco de trabajo. Dicho de una forma simple, es una herramienta que hace que programar ciertas cosas sea más fácil. 

Love está hecho con *C++* y *OpenGL*, los cuales están considerados como muy complicados. La fuente de Love es muy compleja. Pero todo esta complejidad hace que sea muy fácil crear juegos para nosotros.

Por ejemplo, con *love.graphics.ellipse()*, nosotros podemos dibujar una elipse. Pero en cambio, el código que hay detrás es este:

#+BEGIN_SRC C
void Graphics::ellipse(DrawMode mode, float x, float y, float a, float b, int points)
{
    float two_pi = static_cast<float>(LOVE_M_PI * 2);
    if (points <= 0) points = 1;
    float angle_shift = (two_pi / points);
    float phi = .0f;

    float *coords = new float[2 * (points + 1)];
    for (int i = 0; i < points; ++i, phi += angle_shift)
    {
        coords[2*i+0] = x + a * cosf(phi);
        coords[2*i+1] = y + b * sinf(phi);
    }

    coords[2*points+0] = coords[0];
    coords[2*points+1] = coords[1];

    polygon(mode, coords, (points + 1) * 2);

    delete[] coords;
}
#+END_SRC


Podríamos no entender el código anterior y por eso usamos Love. Los creadores de Love hacen el trabajo duro de programación y nos dejan a nosotros la parte divertida. 

** Lua 

Lua es el lenguaje de programación que usa Love. Lua es un lenguaje de programación que no está hecho por o para Love. Los creadores de Love eligieron Lua como lenguaje para su framework. 

Así, ¿qué parte de lo que programamos es Love y qué partes es Lua? Muy simple, todo lo que empieza con Love es parte del framework Love. Todo lo demás es Lua

Por ejemplo, estas funciones son parte de Love:

#+BEGIN_SRC lua
love.graphics.circle("fill", 10, 10, 100, 25)
love.graphics.rectangle("line", 200, 30, 120, 100)
#+END_SRC

Y esto es Lua: 

#+BEGIN_SRC lua
function test(a, b)
return a + b
end
print(test(10, 20))
#+END_SRC

** Cómo funciona Love 

Love llama a *3 funciones*. La primera es *love.load()* . Aquí creamos nuestras variables.

Después llamamos a *love.update() y love.draw()* repetidamente en ese orden. 

Así: love.load() -> love.update() -> love.draw() -> love.update() -> love.draw() -> love.update(), etc.

Detrás de escena, Love llama a esas funciones, y nosotros las creamos y las rellenamos con código. A esto lo llamamos *retrollamada* 

Love está hecho con *módulos*, tales como love.graphics, love.audio, love.filesystem. Hay sobre 15 módulos y cada uno de ellos está enfocado en una cosa. Todo lo que dibujas está hecho con love.graphics. Y todo lo relacionado con sonido está hecho con love.audio. 

Por ahora, nos centraremos en love.graphics.

Love tiene una [[https://www.love2d.org/wiki/Main_Page][wiki]] que explica cada una de las funciones. Si nosotros queremos dibujar un rectangulo, pues iremos en la wiki a [[https://www.love2d.org/wiki/love.graphics][love.graphics()]] y buscaremos en la página por "rectangle". Y esto es lo que encontraremos en [[https://www.love2d.org/wiki/love.graphics.rectangle][rectangle]]. 

Esta página nos dice lo que la función hace y que argumentos necesita. El primer argumento es mode, y necesita de un tipo llamado *DrawMode*. 

Nosotros podemos pinchar en [[https://www.love2d.org/wiki/DrawMode][DrawMode]] para obtener más información. 

DrawMode es una cadena que admite "fill" o "line", y controla el cómo las figuras son dibujadas.

Todos los argumentos siguientes son números. 

Así si queremos dibujar un rectángulo relleno, hacemos lo siguiente:

#+BEGIN_SRC lua
  function love.draw()
    love.graphics.rectangle("fill", 100, 200, 50, 80)
  end
#+END_SRC

Ahora si ejecutamos el juego, podremos ver un rectángulo relleno

* Moviendo un rectángulo 

Ahora podemos empezar con la parte que a mí me gusta llamar "la parte divertida". Vamos a hacer que se mueva. 

Empecemos con las 3 retrollamadas principales.

#+BEGIN_SRC lua
function love.load()

end

function love.update()

end

function love.draw()

end
#+END_SRC


Y ahora dibujaremos un rectángulo.

#+BEGIN_SRC lua
  function love.draw()
    love.graphics.rectangle("line", 100, 50, 200, 150)
  end 
#+END_SRC

El segundo y tercer argumento de esta función son la posición x e y. 

x significa la posición "horizontal" de la pantalla. 0 es la zona izquierda de la pantalla

y significa la posición "vertical" de la pantalla. 0 es la zona alta de la pantalla


[[./img/coordenadas.png]]


Ahora queremos mover el rectángulo. Es hora de empezar a pensar como un programador. ¿Qué es lo que exactamente necesitamos para que el rectángulo se mueva a la derecha? La posición x necesita ir 100, 101, 102, y así. Pero nosotros no podemos cambiar de 100 a 101. 100 es simplemente 100. Necesitamos tener algo que pueda cambiar en cualquier número que nosotros queramos. Eso es, una variable!

En love.load creamos una nueva variable llamada x, y reemplazamos el 100 en love.graphics.rectangle por x. 

#+BEGIN_SRC lua
    function love.load()
      x = 100
    end
    function love.draw()
      love.graphics.rectangle("line", x, 50, 200, 150)
    end
#+END_SRC

Ahora la posición x de nuestro rectángulo es le valor de x.

Ahora queremos hacer que el rectángulo se mueva. Esto lo haremos en love.update(). Cada actualización queremos incrementar x por 5. En otras palabras, x necesita ser el valor de x + 5. Y eso es exactamente lo que vamos a escribir

#+BEGIN_SRC lua
  function love.update()
    x = x + 5
  end
#+END_SRC

Ahora cuando x valga 100, cambiará x en 100 + 5. En la siguiente actualización x valdrá 105 y x cambiará a 105 + 5, etc. 

Ejecuta el juego y verás como el rectángulo se mueve


** Tiempo Delta 

Hemos conseguido mover el rectángulo, pero hay un pequeño problema. Si queremos ejecutar el juego en una computadora distinta, el rectángulo podría moverse con una velocidad distinta. Esto es porque no todas las computadoras actualizan a la misma frecuencia, y esto puede causar problemas. 

Por ejemplo, le decimos a la Computadora A que corre a 100 fps (fotogramas por segundo), y la Computadora B correo a 200 fsp. 

: 100 x 5 = 500
: 200 x 5 = 1000

Así en 1 segundo, x ha incrementado en 500 en la Computadora A, mientras que en la Computadora B lo ha hecho en 1000.

Afortunadamente, hay una solución para esto: el tiempo Delta.

Cuando en Love llamamos a love.update, le pasará un argumento. Añadirá el parámetro dt(tiempo delta) en el love.update y lo mostraremos. 

#+BEGIN_SRC lua
  function love.update(dt)
    print(dt)
    x = x + 5
  end
#+END_SRC

El tiempo Delta es el tiempo que pasa entre la previa y la actual actualización. Así en la computadora A, la cual corre a 100 fps, el tiempo delta tendrá una media de 1/100 lo cual es 0.01.

En la computadora B, el tiempo delta podría ser 1/200, lo cual es 0.005.

Así en un segundo, la computadora A actualiza 100 veces y el incremento de x es de 5 x 0.01 y la computadora B actualiza 200 veces y el incremento es de 5 x 0.005. 

: 100 x 5 * 0.01 = 5
: 200 x 5 * 0.005 = 5

Usando el tiempo Delta en nuestro rectángulo lo moveremos a la misma velocidad en todas la computadoras. 

#+BEGIN_SRC lua
  function love.update(dt)
    x = x + 5 * dt
  end
#+END_SRC

Ahora nuestro rectángulo se moverá 5 píxeles por segundo, en todas la computadoras. 

* Declaración if

Con las declaraciones if, nosotros podemos permitir que trozos de código sean ejecutadas solo cuando una condición ocurre. 

Creamos una declaración como esta: 

#+BEGIN_SRC lua
if condition then
-- code 
end 
#+END_SRC

Una condición, o declaración, es algo que puede ser verdadero o falso

Por ejemplo: 5 > 9

El > significa mayor qué. Así la declaración es que 5 es mayor que 9, lo cual es falso.

Puesto una declaración if en el código del incremento de x.

#+BEGIN_SRC lua
  function love.update(dt)
    if 5 > 9 then
      x = x + 100 * dt
    end
  end 
#+END_SRC

Cuando ejecutamos el juego veremos que el rectángulo no se mueve. Esto es porque la declaración es falsa. Si nosotros lo cambiamos por 5 < 9 (5 es menor que 9), entonces la declaración es verdadera, y el código dentro de la declaración if se ejecutará. 

Con esto, nosotros podemos por ejemplo hacer que x vaya hasta 700, y entonces hacer que se pare de mover con x < 700

#+BEGIN_SRC lua
  function love.update(dt)
    if x < 700 then
      x = x + 100 * dt
    end
  end
#+END_SRC

Si nosotros queremos comprobar si un valor es igual a otro, necesitamos usar dos signos iguales (==). 

Por ejemplo: 4 == 7

Un signo igual es para asignar, 2 signos iguales es para comparar. 

: x = 10 --Asignamos 10 a x
: x == 10 --Comparamos 10 a x

También podemos usar >= y <= si un valor es mayor o igual o menor o igual que otro.

: 10 <= 10 --verdadero, 10 igual a 10 
: 15 >= 4 --verdadero, 15 es mayor que 4


** Buleanos 

Una variable puede ser verdadera o falsa. Este tipo de variables las llamamos buleanas. 

Vamos a hacer una nueva variable llamada mover, con el valor de verdadero (true), y veremos si la variable es verdadera en nuestra declaración. 

#+BEGIN_SRC lua
  function love.load()
    x = 100
    mover = true
  end 

  function love.update(dt)
    --Recuerda usar dos signos ==
    if mover == true then 
      x = x + 100 * dt
    end
  end 
#+END_SRC

mover es verdadero, por lo tanto nuestro rectángulo se moverá. Pero decir mover == true, es redundante. Comprobamos si es verdadero que el valor de mover es verdadero. Simplemente usando mover como una condición correcta sería suficiente. 

#+BEGIN_SRC lua
  if mover then
    x = x + 100 * dt
  end
#+END_SRC

Si queremos comprobar que mover es falso, solo necesitamos poner un *not* delante de él. 

#+BEGIN_SRC lua
  if not move then
    x = x + 100 * dt
  end
#+END_SRC

Si queremos comprobar que un número no es igual a otro número, usamos el símbolo ~.[fn:1]

#+BEGIN_SRC lua
  if 4 ~= 5 then
    x = x + 100 * dt
  end
#+END_SRC

También podemos asignar verdadero o falso a una variable con una declaración.

Por ejemplo:

: mover = 6 > 3

Si comprobamos que mover es verdadero, y entonces cambiamos la variable a falso dentro de la declaración if, esto no es como si saltamos fuera de la declaración. Todo el código siguiente será igualmente ejecutado.

#+BEGIN_SRC lua
  if move then
    move = false
    print("Esto todavía se ejecutará!")
    x = x + 100 * dt
  end
#+END_SRC

** Flechas direccionales

Vamos ahora a hacer que el rectángulo se mueva si mantenemos la tecla direccional derecha presionada. Para esto usamos la función *love.keyboard.isDown* ([[https://www.love2d.org/wiki/love.keyboard.isDown][wiki]]).

Vamos a fijarnos que la de D de Down está en mayúsculas. Esto es un tipo de casing llamado camelCasing. Esto significa que empezamos con la palabra en minúscula, y entonces cada primera letra de las siguientes palabras va en mayúscula. 

Ahora le pasamos la cadena "right" como primer argumento para que compruebe que la flecha direccional derecha está presionada.


#+BEGIN_SRC lua
  if love.keyboard.isDown("right") then
    x = x + 100 * dt
  end
#+END_SRC

Así ahora cuando mantengamos pulsado el botón derecho de las flechas direccionales el rectángulo se moverá. 

También podemos *else* para decirle a nuestro juego qué hacer cuando la condición es falsa. Vamos a hacer que nuestro rectángulo se mueve a la izquierda, cuando no presionamos la tecla derecha. 

#+BEGIN_SRC lua
  if love.keyboard.isDown("right") then
    x = x + 100 * dt
  else
    x = x - 100 * dt --Aquí decrecemos el valor de x
  end
#+END_SRC

También podemos comprobar si otra declaración es verdadera, después del primer falso, con *elseif*. Haremos la prueba de comprobar si la flecha direccional derecha está presionada y si no, comprobaremos la izquierda. 

#+BEGIN_SRC lua
  if love.keyboard.isDown("right") then
    x = x + 100 * dt
  elseif love.keyboard.isDown("left") then
    x = x - 100 * dt
  end
#+END_SRC

Intentaremos hacer que el cuadrado se mueva hacia arriba y abajo también. 

** and & or 

  Con *and* podemos comprobar si múltiples declaraciones son ciertas.

#+BEGIN_SRC lua 
  if 5 < 9 and 14 > 7 then
    print("Ambas declaracione son ciertas")
  end
#+END_SRC

Con *or*, la declaración if se ejecutará si cualquiera de las declaraciones son ciertas.

#+BEGIN_SRC lua 
  if 20 < 9 or 14 > 7 or 5 == 10 then
    print("Una de esas declaraciones es ciertas")
  end
#+END_SRC

* Tablas y bucles for 

** Tablas 

Las tablas son básicamente listas en las cuales podemos guardar valores.

Podemos crear una tabla usando *corchetes* ({ }):

#+BEGIN_SRC lua 
  function love.load()
    frutas = {}
  end 

function love.update()

end

function love.draw()

end
#+END_SRC

Acabamos de crear una tabla llamada frutas. Ahora introduciremos valores dentro de la tabla. Hay múltiples formas de hacer esto.

Una forma es poner los valores dentro de corchetes.

#+BEGIN_SRC lua 
  function love.load()
    --Cada valor es separado por comas, igual que parámetros y argumentos
    frutas = {"manzana", "banana"}
  end
#+END_SRC

También podemos usar la función *table.insert*. El primer argumento es la tabla, el segundo argumento es el valor que nosotros queremos guardar dentro de la tabla. 

#+BEGIN_SRC lua 
  function love.load()
    --Cada valor es separado por comas
    frutas = {"manzana", "banana"}
    table.insert(frutas, "pera")
  end
#+END_SRC

Así ahora después de *love.load* nuestra tabla contendrá "manzana", "banana" y "pera". Para probarlo mostraremos  los valores en la pantalla. Para eso usaremos *love.graphics.print*. 

#+BEGIN_SRC lua 
  function love.draw()
    -- Argumentos (cadena, posición-x, posición-y)
    love.graphics.print("Test", 100, 100)
  end
#+END_SRC

Cuando ejecutemos el juego, veremos el texto "test" escrito. Podemos acceder a los valores de nuestra tabla escribiendo el nombre de las tablas, seguido de corchetes ([ ]). Dentro de esos corchetes, escribimos la posición de los valores que queremos. 

Como hemos dicho, las tablas son listas de valores. Primero hemos añadido "manzana" y "banana", así que esos son el primero y el segundo valor en la lista. Después hemos añadido "pera", así que está en la tercera posición en la lista. La cuarta posición no tiene valor (todavía).

Así si nosotros queremos que aparezca "manzana", primero tenemos que obtener el primer valor de la lista. 

#+BEGIN_SRC lua 
  function love.draw()
    love.graphics.print(frutas[1], 100, 100)
  end
#+END_SRC

Ahora queremos dibujar las tres frutas. Nosotros podríamos usar love.graphics.print 3 veces, cada una con una entrada de tabla diferente.. 

#+BEGIN_SRC lua 
    function love.draw()
      love.graphics.print(frutas[1], 100, 100)
      love.graphics.print(frutas[2], 100, 100)
      love.graphics.print(frutas[3], 100, 100)
#+END_SRC

.. pero imaginemos que tenemos 100 valores en nuestra tabla. Afortunadamente, hay una solución para esto: los bucles for 

** Bucles for

Una bucle for es una forma de repetir una porción de código un número determinado de veces.

Vamos a escribir un bucle for como este:

#+BEGIN_SRC lua 
  function love.load()
    frutas = {"manzana", "banana"}
    table.insert(frutas, "pera")

    for i=1,10 do
      print("hola", i)
    end
  end
#+END_SRC

Si ejecutamos el juego podemos ver que aparece hola 1, hola 2, hola 3, hasta 10.

Para crear un bucle for, primero escribimos *for*. Después escribimos una variable y le damos un valor numérico. Ahí es donde el bucle for empieza. La variable puede ser nombrada de cualquier forma pero es común usar *i*. Esta variable puede solo ser usada dentro del bucle for (al igual que funciones y parámetros). Después describimos el número el cual podría contar. Así por ejemplo *for i=6,18* hace que el bucle empiece en 6 y se mantenga hasta 18.

Hay también un tercer número opcional. Es el cómo incrementa la variable. Si yo escribo *for i=6,18,4* esto hará la sucesión *6, 10, 14, 18. Con esta opción podemos hacer bucles que vayan hacia atrás con *-1*. 

Nuestra tabla empeiza con 1 y tiene 3 valores, así que escribiremos:

#+BEGIN_SRC lua 
  function love.load()
    frutas = {"manzana", "banana"}
    table.insert(frutas, "pera")

    for i=1,3 do
      print(frutas[i])
    end
  end
#+END_SRC

Cuando ejecutemos el juego veremos como se dibuja las 3 frutas. En el primer bucle ejecutará *frutas[1]*, en el segundo *frutas[2]* y en el tercero y último *frutas[3]* 


** Editando tablas 

¿Podemos añadir o borrar valores de una tabla? Podríamos cambiar e lvalor de 3 en otro núemro. Para eso usamos #frutas. Con el símbolo #, podemos obtener la longitud de una tabla. La longitud de una tabla se refiere al número de cosas que hayh en esa tabla. La longitud sería de 3 en nuestro caso.

#+BEGIN_SRC lua 
  function love.load()
    frutas = {"manzana", "banana"}
    table.insert(frutas, "pera")

    print(#frutas)
    --Salida: 3

    for i=1,#frutas do
      print(frutas[i])
    end
  end
#+END_SRC


Usemos este conocimiento para dibujar las tres frutas.

#+BEGIN_SRC lua 
  function love.draw()
    for i=1,#frutas do
      love.graphics.print(frutas[i], 100, 100)
    end
  end
#+END_SRC

Si ejecutamos el juego veremos las tres frutas, esperando que todas se dibujen en la misma posición. Nosotros podemos arreglar esto dibujando cada elemento a una altura distinta.

#+BEGIN_SRC lua 
  function love.draw()
    for i=1,#frutas do
      love.graphics.print(frutas[i], 100, 100 + 50 * i)
    end
  end
#+END_SRC


Así ahora "manzana" se dibujará en la posición 100 + 50 * 1, la cual es 150. Entonces la "banana" se dibujará a 200 y la pera a 250. 

Si queremos añadir otra fruta, no tenemos que cambiar nada, será dibujada automáticamente. Añadamos "piña" 

#+BEGIN_SRC lua 
  function love.load()
    frutas = {"manzana", "banana"}
    table.insert(frutas, "pera")
    table.insert(frutas, "piña")
  end
#+END_SRC


También podemos borrar valores de nuestra tabla. Para eso usamos *table.remove*. El primer argumento es la tabla de la cual queremos borrar algo, el segundo argumento es la posición que queremos borrar. Así, si queremos borrar la banana, haremos lo siguiente:

#+BEGIN_SRC lua 
  function love.load()
    frutas ={"manzana", "banana"}
    table.insert(frutas, "pera")
    table.insert(frutas, "piña")
    table.remove(frutas, 2)
  end
#+END_SRC

Cuando borramos un valor de una tabla con *table.remove*, todos los elementos siguientes se mueven hacia arriba. Así lo que está en la posicion 3 estará ahora en la posición 2 en la tabla. 

También podemos añadir o cambiar los valores dentro de la tabla directamente. Por ejemplo, podemos cambiar "manzana" por "tomate":

#+BEGIN_SRC lua 
  function love.load()
    frutas = {"manzana", "banana"}
    table.insert(frutas, "pera")
    table.insert(frutas, "piña")
    table.remove(frutas, 2)
    --El valor que queremos cambiar es el valor 1
    frutas[1] = "tomate"
  end
#+END_SRC

** Ipairs 

Vuelta a los bucles for. Hay una forma distinta y más fácil  de recorrer una tabla. Podemos usar un bucle ipairs. 

#+BEGIN_SRC lua 
  function love.load()
    frutas = {"manzana", "banana"}
    table.insert(frutas, "pera")
    table.insert(frutas, "piña")
    table.remove(frutas, 2)
    frutas[1] = "tomate"

    for i,v in ipairs(frutas) do
      print(i,v)
    end

    --Salida:
    --1, "tomate"
    --2, "pera"
    --3, "piña"
  end
#+END_SRC

Este bucle de bucles o llamadas iterativas atraviesan todos los valores de la tabla. Las variables *i* nos dicen la posición de la tabla, *v* es el valor de la posición en la tabla. Esto es básicamente un atajo para *frutas[i]*. Por ejemplo, en la primera iteracción los valores de las variables para las variables i serían 1 y v sería "manzana". En la segunda iteracción, i y v serían 2 y "pera" respectivamente. Ahora usaremos los ipairs para dibujar nuestras tablas. 

#+BEGIN_SRC lua 
  function love.draw()
    --i y v son varialbes, así que podemos nombrarlas como queramos
    for i,frt in ipairs(frutas) do
      love.graphics.print(frt, 100, 100 + 50 * i)
    end
  end
#+END_SRC

* Objetos 

En el capítulo anterior usamos tablas como listas numeradas, pero también podemos guardar los valores de una forma diferente: Con cadenas de texto. 

#+BEGIN_SRC lua 
  function love.load()
    --rect es una contracción de rectángulo
    rect = {}
    rect["anchura"] = 100
  end
#+END_SRC

"Anchura" en este caso es lo que llamaríamos un valor clave o propiedad. Así la tabla cuadrada tiene ahora la propiedad de "anchura" con un valor de 100. No necesitamos usar cadenas cada vez que queramos crear una propiedad. Un punto (.) es el atajo para esto. Añadamos más propiedades.

#+BEGIN_SRC lua 
  function love.load()
    rect = {}
    rect.x = 100
    rect.y = 100 
    rect.width = 70
    rect.height = 90
  end 
#+END_SRC

Ahora que tenemos nuestras propiedades podemos empezar a dibujar el rectángulo.

#+BEGIN_SRC lua 
  function love.draw()
    love.graphics.rectangle("line", rect.x, rect.y, rect.width, rect.height)
  end
#+END_SRC

Y podemos moverlo

#+BEGIN_SRC lua 
    function love.load()
      rect = {}
      rect.x = 100
      rect.y = 100
      rect.width = 70
      rect.height = 90

      --Añadimos la propiedad velocidad
      rect.speed = 100
    end

    function love.update(dt)
      rect.x = rect.x + rect.speed * dt
    end

#+END_SRC


Ahora tenemos un rectángulo que se mueve de nuevo, pero mostramos el poder de las tablas. Ahora queremos crear múltiples rectángulos moviéndose. Para esto vamos a usar una tabla como una lista. Haremos una lista de rectángulos. Moveremos el código dentro de *love.load* a una nueva función y crearemos una nueva talba en *love.load* 

#+BEGIN_SRC lua 
  function love.load()
    listaDeRectangulos = {}
  end 

  function createRectangulo()
    rect = {}
    rect.x = 100
    rect.y = 100 
    rect.width = 70
    rect.height = 90
    rect.speed = 100 

  --Ponemos el nuevo rectángulo en la lista
    table.insert(listaDeRectangulos, rect)
  end 
#+END_SRC


Así ahora cada vez que llamemos a createRectangulo, un nuevo objeto rectángulo será añadido a nuestra lista. Eso es correcto, una talba rellena de tablas. Haremos eso, así que cada vez que presionemos la barra espaciadora, llamaremos a createRectangulo. Haremos esto con la llamada *love.keypressed*. 

#+BEGIN_SRC lua 
  function love.keypressed(key)
    if key == "space" then 
      createRectangulo()
    end
  end
#+END_SRC

Cada vez que presionemos una tecla, Love llamará a *love.keypressed* y le pasará la tecla presionada como argumento. Si esa tecla es la barra espaciadora, llamaremos a createRectangulo. 

La última cosa a hacer es cambiar nuestra actualización y que dibuje esa función. 

#+BEGIN_SRC lua 
    function love.update(dt)
      for i,v in ipairs(listaDeRectangulos) do
        v.x = v.x + v.speed * dt
      end
    end

    function love.draw(dt)
      for i,v in ipairs(listaDeRectangulos) do
        love.graphics.rectangle("line", v.x, v.y, v.width, v.height)
      end
    end
#+END_SRC

Ahora cuando ejecutemos el juego, un rectángulo en movimiento aparecerá cada vez que presionemos la barra espaciadora.

* Múltiples archivos y ámbitos 

** Múltiples archivos 

Con múltiples archivos nuestro código parecerá más organizado y más fácil de navegar. Vamos a crear un archivo llamado *ejemplo.lua*. Nos vamos a asegurar que está en el mismo directorio que *main.lua* 

Dentro de este fichero, vamos a crear una variable. Pondremos *--! file:* arribad de todos los bloques de código para hacer más claro que en ese archivo hemos puesto el código.


#+BEGIN_SRC lua 
  --! file: ejemplo.lua 
  test = 20
#+END_SRC

Ahora en *main.lua*, escribiremos *print(test)*. Cuando ejecutemos el juego, veremos que el test es igual a *nil*. Esto es porque no hemos cargado el fichero primero. Para hacer esto usaremos *require* pasándole el nombre del fichero como primer argumento.

#+BEGIN_SRC lua 
  --! file:main.lua
  --Dejamos fuera la extensión
  require("ejemplo")
  print(test)
#+END_SRC

Recordar no añadir la extensión *.lua* en el nombre del fichero, porque Lua hace esto por nosotros.

También podemos poner el archivo en un subdirectorio, pero en ese caso tendremos que añadir el path completo. 

#+BEGIN_SRC lua 
--Usamos . en vez de / 
require("path.de.ejemplo")
#+END_SRC

Ahora cuando ejecutemos el juego veremos que test vale 20. 

*test* en este caso es lo que llamamos una *variable global*. Esto es una variable que puede ser usada en donde sea de nuestro proyecto. Lo opuesto a variable global, es una *variable local*. Podemos crear una variable local escribiendo *local* delante del nombre de la variable. 

#+BEGIN_SRC lua 
--! file: ejemplo.lua
local test = 20
#+END_SRC

Cuando ejecutemos el juego nos dirá que test valdrá de nuevo *nil*. Esto es a causa de su *ámbito*. 


** Ámbito

Una variable local está limitada a su *ámbito*. En el caso de test, el ámbito es el archivo ejemplo.lua. Esto quiere decir que test puede ser usado en cualquier lugar del archivo, pero no en otros archivos. 

Si queremos crear una variable local dentro de un *bloque*, como una función, una declaración if, o un bucle for, entonces eso sería el ámbito de la variable. 

#+BEGIN_SRC lua 
    --! file: ejemplo.lua
    if true then
      local test = 20
    end

    print(test)
    --Salida: nil

#+END_SRC

test es nil, porque hemos ejecutado la orden print fuera de su ámbito. 

Los parámetros de funciones son como variables locales. Solo existen dentro de la función.

Para realmente entender como el ámbito funciona, echemos un vistazo a la siguiente código: 

#+BEGIN_SRC lua 
  --! file: main.lua
  test = 10
  require("ejemplo")
  print(test)
  --Salida: 10
  --! file ejemplo.lua
  local test = 20 

  function alguna_funcion(test)
    if true then
      local test = 40 
      print(test)
      --Salida: 40
    end
    print(test)
    --Salida: 30
  end

  alguna_funcion(30)

  print(test)
  --Salida: 20
#+END_SRC


Si ejecutamos el juego, podremos ver dibujado: 40, 30, 20, 10. Echemos un ojo a este código paso a paso.

El primer print dentro de la declaración if, es 40. Después de la declaración if, dibujaremos test de nuevo, ahora es 30, lo cual es porque hemos pasado ese argumento. El parámetro test no es afectado por el test que hay dentro de la declaración if. Dentro de la declaración if la variable local toma prioridad sobre el parámetro. 

Fuera de la función también dibujamos print. Esta vez vale 20. El test creado al principio del fichero ejemplo.lua no será afectado por el test dentro de la función.

Finalmente dibujamos test del fichero main.lua, y éste vale 10. La variable global no es afectada por la variable local dentro del fichero ejemplo.lua 

En esta visualización del ámbito de cada variable test se ve más claro:

Cuando creamos un variable local, no hay que asignarle un valor. 

#+BEGIN_SRC lua 
local test
test = 20
#+END_SRC

** Devolviendo un valor 

Como las funciones, los archivos pueden devolver un valor. Si queremos devolver 10 al final del archivo ejemplo.lua, y dentro del archivo main.lua escribimos *print(require("ejemplo"))* , entonces veremos que devuelve 10. 


* Bibliotecas 

Una biblioteca es código que o el mundo puede usar y añadir ciertas funcionalidades a su proyecto. 

Probemos varias bibliotecas. Vamos a usar las bibliotecas *tick* y *rxi*. Podemos encontrar esas bibliotecas en [[https://github.com/rxi/tick][github]].

Ahora vamos a [[https://raw.githubusercontent.com/rxi/tick/master/tick.lua][copiar el código]]. 

Ahora vamos a crear un nuevo archivo llamado *tick.lua* y pegaremos el código en él. 

Ahora seguiremos las siguientes instrucciones de la página de Github. Primero vamos  a requerirlo.

#+BEGIN_SRC lua 
  function love.load()
    tick = require "tick"
  end
#+END_SRC

Aquí vemos que *require* no tiene los paréntesis. Esto es porque cuando le pasamos un solo argumento, no temeos que usarlos. Ahora que se recomienda usarlos para cualquier otra función, pero con *require* lo más común es no usarlos. 

Lo siguiente que vamos a hacer es poner *tick.update(dt)* en nuestro actualizador. 

#+BEGIN_SRC lua 
  function love.update(dt)
    tick.update(dt)
  end
#+END_SRC

Y ahora estamos preparados para usar la biblioteca. Crearemos un rectángulo que se dibujará después de 2 segundos.

#+BEGIN_SRC lua 
  function love.load()
    tick = require "tick"

    --Crearemos un buleano
    dibujarRectangulo = false

    --El primer argumento es una función
    --El segundo argumento es el tiempo que lleva llamar a la función
    tick.delay(function () dibujarRectangulo = true end, 2)
  end

  function love.draw()
    --Si dibujarRectangulo es true se dibujará un rectángulo
    if dibujarRectangulo then
      love.graphics.rectangle("fill", 100, 100, 300, 200)
    end
  end
#+END_SRC

¿Hemos pasado una función como un argumento? Seguro, ¿por qué no? Una función es un tipo de variable después de todo. Así como podemos ver, con esta biblioteca poner un retraso a las cosas. Hay toneladas de bibliotecas con todo tipo de funcionalidades. 

No te sientas culpable de usar una biblioteca. ¿Para qué reinventar la rueda? Eso es, a menos que estés interesado en aprenderlo. 

Las bibliotecas no son mágicas. Está todo el código que podríamos escribir nosotros mismos. Crearemos una biblioteca en el futuro para entender mejor sobre ellas. 

** Bibliotecas estándar

Lua tiene una serie de bibliotecas de serie. Esas bibliotecas son llamadas *Bibliotecas estándar*. Son las funciones que hay contruidas dentro de Lua. *print*, por ejemplo, es parte de esas bibliotecas estándar. También *table.insert* y *table.remove* 

Una biblioteca estándar muy importante que no hemos visto es la biblioteca *math*. Ésta proporciona funciones matemáticas, las cuales son muy útiles para hacer un juego. 

Por ejemplo, *math.random* nos proporciona un número aleatorio. Como ejemplo, vamos a poner un rectángulo en una posición al azar al presionar la barra espaciadora. 

#+BEGIN_SRC lua 
  function love.load()
    x = 30
    y = 50
  end

  function love.draw()
    love.graphics.rectangle("line", x, y, 100, 100)
  end

  function love.keypressed(key)
    --Si la barra espaciadora es pulsada, entonces...
    if key == "space" then
      --x e y será un número aleatorio entre 100 y 500
      x = math.random(100, 500)
      y = math.random(100, 500)
    end
  end
#+END_SRC


Ahora que hemos entendido lo que es una biblioteca, podremos empezar a usar bibliotecas de clase

* Clases 

Las clases son como planos. Podemos crear muchas casas usando un plano. De igual manera creamos muchos objetos de una clase. 

[[./img/clases.png]]

Para clases, vamos a usar la biblioteca: [[https://github.com/rxi/classic#start-of-content][classic]] 

Una vez tengamos el nuevo fichero llamado *classic.lua* lo requeriremos. 

#+BEGIN_SRC lua 
  function love.load()
    Object = require "classic"
  end
#+END_SRC

Ahora estamos preparados para hacer una clase. Crearemos un nuevo fichero llamado rectangulo.lua y pondremos en él el siguiente código:

#+BEGIN_SRC lua 
  --! file: rectangulo.lua

  --Ahora usaremos los dos puntos(:) en vez de un punto (.)
  Rectangulo = Object:extend()

  function Rectangulo.new(self)
    self.test = math.random(1, 1000)
  end
#+END_SRC

Todo será explicado pero primero pongamos el siguiente código en nuestro *main.lua* 

#+BEGIN_SRC lua 
  --! file: main.lua 
  function love.load()
    Object = require "classic"
    --No olvidemos cargar el fichero
    require "rectangulo"

    r1 = Rectangulo()
    r2 = Rectangulo()
    print (r1.test, r2.test)
  end
#+END_SRC


Cuando ejecutemos el juego, veremos que aparecerán dos números aleatorios.

Así vamos a ver el código paso a paso. Primero creamos un nueva clase con *Rectangulo = Object:extend()*. Esto hace que *Rectangulo* se convierta en una clase. Esto será nuestro primer plano original. Como opuesto a las propiedades, las clases normalmente están escritas usando mayúsculas. 

En *main.lua* escribimos *r1 = Rectangulo()*. Aunque *Rectangulo* sea una tabla, todavía podemos llamarlo como si fuera una función. El cómo trabaja lo veremos en otro capítulo. Pero llamando a *Rectangulo()*, creamos una nueva instancia. Lo que esto significa es que cogemos los planos originales y creamos un nuevo objeto con todas las clases como características. Cada nueva instancia es única. 

Para probar que r1 es único, crearemos otra instancia llamada r2. Ambas tienen la propiedad *test*, pero diferentes valores. 

Cuando llamamos a *Rectangulo()*, se ejecuta *Rectangulo.new*. Esto es lo que llamamos un *_constructor_* 

El parámetro *self*, es la instancia que estamos modificando. Si tecleamos *Rectangulo.test= math.random(0, 1000)*, le damos propiedades al plano, y no a una instancia hecha con el plano. 

Vamos a hacer algunos cambios a nuestras clase. 

#+BEGIN_SRC lua 
  --! file: rectangulo.lua
  function Rectangulo.new(self)
    self.x = 100
    self.y = 100
    self.altura = 200
    self.anchura = 150
    self.velocidad = 100
  end

  function Rectangulo.update(self, dt)
    self.x = self.x + self.velocidad * dt
  end

  function Rectangulo.draw(self)
    love.graphics.rectangle("line", self.x, self.y, self.altura, self.anchura)
  end
#+END_SRC

Es como lo que hemos hecho en el capítulo 8. Excepto que esta vez hemos puesto el código del movimiento y el dibujado en el objeto. Ahora solo necesitamos llamar a *update* y *draw* en main.lua

#+BEGIN_SRC lua 
    --! file: main.lua

    function love.load()
      require = "rectangulo"
      r1 = Rectangulo()
      r2 = Rectangulo()
    end

    function love.update(dt)
      r1.update(r1, dt)
    end

    function love.draw()
      r1.draw(r1)
    end

#+END_SRC

Nosotros también podemos hacer esto con las funciones también.

#+BEGIN_SRC lua 
    --! file: rectangulo.lua

    --Lua devuelve esto en: Rectangulo.new(self)
    function Rectangulo:new()
      self.x = 100
      self.y = 100
      self.altura = 200
      self.anchura = 150
      self.velocidad = 100
    end

  --Lua devuelve esto en: Rectangulo.update(self, dt)
  function Rectangulo:update(dt)
  self.x = self.x + self.velocidad * dt
  end

  --Lua devuelve esto en: Rectangulo.draw(self)
  function Rectangulo:draw()
    love.graphics.rectangle("line", self.x, self.y, self.altura, self.anchura)
  end 
#+END_SRC

Vamos a añadir algunos parámetros a *Rectangulo:new()* 

#+BEGIN_SRC lua 
  --! file: rectangulo.lua
  function Rectangulo:new(x, y, anchura, altura)
    self.x = x
    self.y = y
    self.anchura = anchura
    self.altura = altura
    self.velocidad = 100
  end

#+END_SRC


Con esto podemos dar a r1 y r2 su propia posición y tamaño.

#+BEGIN_SRC lua 
    --! file: main.lua

    function love.load()
      r1 = Rectangulo(100, 100, 200, 50)
      r2 = Rectangulo(180, 300, 25, 140)
    end

    function love.update(dt)
      r1:update(dt)
      r2:update(dt)
    end

    function love.draw()
      r1:draw()
      r2:draw()
    end
#+END_SRC


Ahora tenemos dos rectángulos moviéndose. Esto es lo que hace a las clases tan grandes. r1 y r2 son lo mismo y también son únicas.

Otra cosa que hace grande a las clases es la *herencia* 


** Herencia 


Con la herencia, podemos extender nuestra clase. En otras palabras, podemos hacer copia de nuestro plano, y añadir nuevas características sin tener que tocar el original.


[[./img/herencia.png]]

Esto quiere decir que si tienes un juego con monstruos, cada monstruo tiene su propio ataque y se mueven de forma diferente. Pero ellos obtienen el mismo daño y son capaces de morir. Esas características que se solapan se podrían poner en lo que se llama una *superclase* o *clase base*. Éstas proporcionan unas características que todos los monstruos tienen. Y luego cada clase monstruo puede extender esa clase base y añadir sus propias características.

Vamos a crear otra figura en movimiento, un círculo. ¿Qué tienen en común nuestro rectángulo y nuestro círculo? Ambos se mueven. Así haremos una clase base para ambas figuras. 

Crearemos un nuevo fichero llamado figura.lua y pondremos en él el siguiente código:

#+BEGIN_SRC lua 
  --! file: figura.lua
  Figura = Object:extend()

  function Figura:new(x, y)
    self.x = x
    self.y = y
    self.velocidad = 100
  end

  function Figura:update(dt)
    self.x = self.x + self.velocidad * dt
  end
#+END_SRC

Nuestra clase base Figura ahora maneja el movimiento. Podemos pensar que clase base es solo un término. "A es una clase base de B". Una clase base es todavía igual que otra clase. La diferencia es el cómo la usamos.

De todas formas, ahora que tenemos una clase base que maneja nuestro movimiento, podemos hacer *Rectangulo* una extensión de Figura, y borrar su actualizador.

#+BEGIN_SRC lua 
  --! file: rectangulo.lua
  Rectangulo = Figura:extend()

  function Rectangulo:new(x, y, anchura, altura)
    Rectangulo.super.new(self, x, y)
    self.anchura = anchura
    self.altura = altura
  end

  function Rectangulo:draw()
    love.graphics.rectangule("line", self.x, self.y, self.anchura, self.altura)
  end
#+END_SRC

Con *Rectangulo = Figura:extend()* hacemos de /Rectangulo/ una extensión de Figura.

Figura tiene su propia función llamada *:new()*. Para crear *Rectangulo:new()*, hemos sobre escrito la función original. Esto quiere decir que cuando llamemos a Rectangulo(), no se ejecutará Figura:new() en vez de Rectangulo:new().

Pero rectangulo tiene la propiedad *super*, la cual es la clase desde donde /Rectangulo/ es extendido. Con *Rectangulo.super* podemos acceder a las funciones de la clase base, y usarlas para llamar a *Figura:new()*. 

Hemos pasado /self/ como primer argumento a nosotros mismos, y no podemos permitir que Lua lo maneje con un doble punto (:), por eso no llamaremos a la función como la instancia. 

Ahora necesitamos hacer una clase circulo. Crearemos un nuevo fichero llamado *circulo.lua* y escribiremos el siguiente código.

#+BEGIN_SRC lua 
  --! file: circulo.lua
  Circulo = Figura:extend()

  function Circulo:new(x, y, radio)
    Circulo.super.new(self, x, y)
    --Un círculo no tiene una anchura y altura sino un radio.
    self.radio = radio
  end

  function Circulo:draw()
    love.graphics.circle("line", self.x, self.y, self.radio)
  end
#+END_SRC

Así hacemos al /Circulo/ una extensión de /Figura/. Le pasamos x e y a la función /new()/ de /Figura/ con /Circulo.super.new(sefl, x, y)/.

También le damos a nuestra clase /Circulo/ su propia función /Draw/. Así es como dibujamos un círculo. Los círculos no tienen una altura y anchura sino un radio.

Y ahora en el fichero /main.lua/ cargaremos /figura.lua/ y /circulo.lua/ y cambiaremos r2 a circulo

#+BEGIN_SRC lua 
  --! file: main.lua

  function love.load()
    Object = require "classic"
    require "figura"

    require "rectangulo"
    require "circulo"

    r1 = Rectangulo(100, 100, 200, 50)

    r2 = Circulo(180, 300, 50)
  end

#+END_SRC

Ahora cuando ejecutemos el juego veremos un rectángulo y un círculo moviéndose.

**  Una cosa más

Vayamos a través del código una vez maś.

Primero hemos cargado la biblioteca /classic/ con /require "classic"/. Cargada esta biblioteca nos devuelve una tabla, y guardamos en la tabla el *Objeto*. Esto es lo más básico para simular una clase. Porque Lua no tiene clases, pero usando /classic/ tenemos una muy buena imitación de una clase.

Luego cargamos /figura.lua/. En ese fichero hemos creado una nueva clase llamada *Figura*. Usaremos esa clase como una *clase base* para *Rectangulo* y *Circulo*. Las dos cosas que esas clases tiene en común es que ellas tiene una propiedad x e y, y que se mueven horizontalmente. Esas similitudes las ponemos en /Figura/.

Ahora creamos la clase *Rectangulo*. Hacemos una extensión de nuestra clase base /Figura/. Dentro de la función /:new()/, el *constructor*, llamamos el constructor de nuestra clase base con /Rectangulo.super.new(self, x, y)/. Ahora pasamos /self/ como primer argumento, así que /Figura/ usará la instancia de nuestro plano, y no el plano en sí. Le damos a nuestro rectángulo unas propiedades  anchura y altura, y le damos una función /draw/.

Haremos algo similar para el /Circulo/. Aunque en vez de altura y anchura le damos una propiedad radio.

Ahora que tenemos nuestras clases preparadas, podemos empezar a hacer las *instancias* de esas clases. Con /r1 = Rectangulo(100, 100, 200, 50)/ creamos una instancia de nuestra clase /Rectangulo/. Es un objeto hecho con nuestro plano y no el plano en sí. Cualquier cambio que hagamos a nuestra instancia no afectará a la clase. Actualizamos y dibujamos esta instancia, y para eso usamos los dos puntos (:). Esto es porque necesitamos pasar nuestra instancia como primer argumento, y los dos puntos hace que Lua lo haga por nosotros.

Y finalmente hacemos lo mismo con r2, excepto que ahora hacemos un Circulo. 

* Imágenes 

Crear y usar imágenes es una tarea muy fácil en Love. Primero necesitamos una
imagen. Usaremos esta imagen

[[./img/oveja.png]]

Por supuesto, puedes usar la imagen que quieras. siempre que sea del tipo png. Ten seguro que la imagen está en el mismo directorio que tu fichero /main.lua/ 

Primero necesitamos cargar la imagen, y guardarla en una variable. Para esto usaremos /love.graphics.newImage/. Le pasañmos el nombre de la imagen como una cadena de texto como primer argumento. ASí tendremos: 

#+BEGIN_SRC lua 
  function love.load()
    miImagen = love.graphics.newImage("oveja.png")
  end
#+END_SRC

También podemos poner la imagen en un subdirectorio, pero en ese caso tendremos que estar seguros de incluir el path completo. 

#+BEGIN_SRC lua 
  miImagen = love.graphics.newImage("path/a/oveja.png")
#+END_SRC


Ahora nuestra imagen está guardada dentro de *miImagen*. Ahora podemos usar /love.graphics.draw/ para dibujar nuestra imagen. 

#+BEGIN_SRC lua 
  function love.draw()
    love.graphics.draw(miImagen, 100, 100)
  end
#+END_SRC

Y así es como se dibuja una imagen. 

** Argumento .draw() 

Vamos a echar un vistazo a otro argumento de /love.graphics.draw()/. Todos los argumentos dentrás de image son opcionales. 

#+BEGIN_SRC lua 
r
#+END_SRC

La *r* otación (o ángulo). Todos los ángulos en Love son en radianes. Explicaremos más sobre los radianes en otro capítulo. 

*sx* e *sy* 

La escala *x* y la escala *y*. Para hacer por ejemplo una imagen dos veces más grande de lo que es.

#+BEGIN_SRC lua 
  love.graphics.draw(miImagen, 100, 100, 0, 2, 2)
#+END_SRC

También podemos usarlo para mostrar una imagen espejo de la otra 

#+BEGIN_SRC lua 
  love.graphics.draw(miImagen, 100, 100, 0, -1, 1)
#+END_SRC

*ox* y *oy* 

El origen *x e y* de la imagen. 

Por defecto, todo el escalado y la rotación es basada en la zona arriba-izquierda de la imagen. 

[[./img/origen1.png]]


Esto es basado en el _origen_ de la imagen. Si queremos escalar la imagen desde el centro, pondremos entonces el origen en el centro de la imagen. 

#+BEGIN_SRC lua 
  love.graphics.newImage(miImagen, 100, 100, 0, 2, 2, 39, 50)
#+END_SRC


[[./img/origen2.png]]


*kx* y *ky* 

Son para estirar las imágenes. Por ejemplo:



[[./img/estirar.png]]


** Objeto imagen 

La imagen que /love.graphics.newImage/ devuelve, es en realidad un *objeto*. Un objeto [[https://love2d.org/wiki/Image][imagen]]. Este objeto tiene funciones que pueden usarse para editar nuestra imagen u obtener datos de ella. 

Por ejemplo, podmeos usar *:getWidth()* y *:getHeight()* para obtener la anchura y la altura de la imagen. Podemos usar esto para poner el origen en el centro de nuestra imagen. 

#+BEGIN_SRC lua 
    function love.load()
      miImagen = love.graphics.newImage("oveja.png")
      anchura = miImagen:getWidth()
      altura = miImagen:getHeight()
    end

    function love.draw()
      love.graphics.draw("oveja.png", 100, 100, 0, 2, 2, anchura/2, altura/2)
    end
#+END_SRC





















* Footnotes

[fn:1] Tilde en inglés virgulilla en español. 
