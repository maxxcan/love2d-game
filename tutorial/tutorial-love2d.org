#+TITLE: tutorial-love2d
#+AUTHOR: Patricio Martínez 
#+DATE: <2018-04-20 vie>
#+EMAIL: maxxcan@disroot.org

* Introducción 

Este tutorial es una traducción casi literal de un tutorial de introducción de Love2D. La traducción la realizo tanto para aprender
como para que haya más documentación en español sobre este framework. 

El original está en [[http://sheepolution.com/learn/book/contents][Sheepolution]]

Este tutorial está escrito para personas sin experiencia en programación. Así que si no tienes ninguna experiencia en programación, espero que este tutorial también ayude con tu formación en ese área. 

* Instalación 

Los capítulos 2 y 3 se pueden realizar sin necesidad de instalar nada. Puedes usar [[https://repl.it/languages/lua][repl.it]] como alternativa. 

** Love 

Para instalar en todo caso Love, en nuestro ordenador tenemos que ir a [[https://www.love2d.org/][love2d.org]]. Una vez allí podemos elegir la versión que necesitemos según nuestra computadora y sistema operativo 

En mi caso uso Archlinux con lo que el framework nos lo podemos descargar directamente desde AUR con el gestor de paquetes yaourt. Tan solo tenemos que ejecutar el comando: 

: yaourt -S love 

** Editor 

Para este tutorial podemos elegir el editor o IDE que nos apetezca. Yo en mi caso usaré Emacs que además de soporte para Lua (el lenguaje de este framework) hay un pequeño modo para love2d que nos ayuda. 

El autor del artículo original recomienda *Zerobrane* que es un IDE con muchas características útiles para trabajar con Lua. Puedes descargarlo desde [[https://studio.zerobrane.com/support][aquí.]] 

Si posees Archlinux también puedes descargarlo usando *yaourt* 


Una vez tengamos abierto nuestro editor o IDE preferido lo abrimos y creamos un fichero con el siguiente código:

#+BEGIN_SRC lua
  function love.draw()
    love.graphics.print("Hola Mundo!", 100, 100)
  end 

#+END_SRC

Y lo salvamos con el nombre de *main.lua* 

* Variables 

¿Qué es a + b?

Una variable es un símbolo que apunta a un valor. Para ello tendremos que indicarle cual es el valor al que apunta. 

Si queremos saber cual es la suma de a + b entonces tendremos que asignarle valores. Para hacer esto escribimos:

: a = 5
: b = 3
: print(a + b)

-- Resultado: 8

La palabra que usemos para guardar los valores puede ser cualquiera.

: sheep = 3
: test = 20
: PANTS = 1024
: asdfghjkl = 42 

La variables son sensibles a mayúsculas y minúsculas. Esto significa que no es lo mismo la variable a que la variable A. Por ejemplo.

: sheep = 3 
: SHEEP = 10
: SHeEp = 200

Estas son 3 variables distintas

A la hora de asignar variables podemos hacer algo más que asignar valores. 

: a = 20 - 10 -- Sustracción
: b = 20 * 10 -- Multiplicación
: c = 20 / 10 -- División
: d = 20 ^ 10 -- Exponenciación 

Para los números con decimales usamos el punto. 

: a = 10.4
: b = 2.63
: c = 0.1
: pi = 3.141592

* Cadenas de texto

Una variable también puede guardar un texto.
: texto = "Hola Mundo"

Podemos conectar cadenas de caracteres usando dos puntos (..)

: nombre = "Daniel"
: edad = "22"
: texto = "Hola, mi nombre es " .. nombre .. ", y tengo la edad de " .. "años"
: print(texto)

Salida -- "Hola, mi nombre es Daniel y tengo la edad de 22 años"

** Reglas nombre variables 

Hay unas pocas reglas para nombrar a las variables. Primero de todo, la variable puede tener un número en ella, pero no al principio. 

: test8 -- Bien
: te8st -- Bien
: 8test -- Mal

El nombre de la variable tampoco puede incluir caracteres especiales tales como @#$%^&* 

Y finalmente, el nombre de la variable no puede ser una palabra clave. Una palabra clave es una palabra que el lenguaje de ordenador usa. Aquí tenemos una lista de palabras clave: 

| and    | break  | do   | else     | elseif |
| end    | false  | for  | function | if     |
| in     | local  | nil  | not      | or     |
| repeat | return | then | true     | until  |
| while  |        |      |          |        |

* Funciones 

Con las funciones nosotros guardamos trozos de código. Esto nos permite ejecutar este código en donde nosotros queramos. 

Hay dos formas de crear una función: 

#+BEGIN_SRC lua
  ejemplo = function ()
    print("Hola Mundo!")
  end
#+END_SRC

Y la forma más común:

#+BEGIN_SRC lua
  function ejemplo()
    print("Hola Mundo!")
  end
#+END_SRC

Primero empezamos usando la palabra clave *function*, seguido del nombre de la función. Una función es un tipo de varialbe, así que las mismas reglas que aplicamos cuando nombramos uan variable se aplica para las unciones. Después del nombre ponemos unos paréntesis. Ahora podemos empezar a escribgir el código que queremos poner dentro de la función. 

Una vez hecho esto, tenemos que escribir el nombre de la función para obtener el resultado. Esto es lo que llamamos *llamada a una función* 

** Parámetros 

Veamos el siguiente código 

#+BEGIN_SRC lua
  function ejemplo(num)
    print("Me gusta el número " .. num)
  end 
#+END_SRC

: ejemplo(15)
: ejemplo(2)
: ejemplo(100)

: -- Salida:
: -- "Me gusta el número 15"
: -- "Me gusta el número 2"
: -- "Me gusta el número 100"

Dentro del paréntesis de la función nosotros podmeos poner lo que llamamos *parámetros*. Los parámetros son variables temporales que solo existen dentro de la función. En este caso usamos el parámetro num. Ahora podemos usar num como cualquier otra variable.

** Return 

Las funciones puede devolver un valor, el cual podemos guardarlo en una variable, por ejemplo. Podemos devolver un valor usando la palabra clave *return* 

#+BEGIN_SRC lua
  function dameCinco()
    return 5
  end

a = dameCinco()
print(a)

#+END_SRC

: -- Salida: 5

Vemos el valor que devuelve dameCinco gracias a *return* 

Otro ejemplo: 

#+BEGIN_SRC lua
  -- Múltiples argumentos y parámetros separados por comas
  function sum(a, b)
    return a + b
  end

  print(sum(200, 95))
#+END_SRC

: -- Salida:
: -- 34
: -- 295

Nuestra función sum devuelve la suma de a y de b.

** ¿Por qué las funciones?

Usando funciones nosotros no tenemos que repetir cierto código una y otra vez de nuevo. Podemos simplemente hacer llamadas a la función que necesitemos. Esto es grande, porque nosotros podemos cambiar una función en el futuro, y no tener la necesidad de tener que cambiarla en todas los lugares donde la hemos puesto. 
* Love 
** Qué es Love 

Love es lo que llamamos un *framework* o marco de trabajo. Dicho de una forma simple, es una herramienta que hace que programar ciertas cosas sea más fácil. 

Love está hecho con *C++* y *OpenGL*, los cuales están considerados como muy complicados. La fuente de Love es muy compleja. Pero todo esta complejidad hace que sea muy fácil crear juegos para nosotros.

Por ejemplo, con *love.graphics.ellipse()*, nosotros podemos dibujar una elipse. Pero en cambio, el código que hay detrás es este:

#+BEGIN_SRC C
void Graphics::ellipse(DrawMode mode, float x, float y, float a, float b, int points)
{
    float two_pi = static_cast<float>(LOVE_M_PI * 2);
    if (points <= 0) points = 1;
    float angle_shift = (two_pi / points);
    float phi = .0f;

    float *coords = new float[2 * (points + 1)];
    for (int i = 0; i < points; ++i, phi += angle_shift)
    {
        coords[2*i+0] = x + a * cosf(phi);
        coords[2*i+1] = y + b * sinf(phi);
    }

    coords[2*points+0] = coords[0];
    coords[2*points+1] = coords[1];

    polygon(mode, coords, (points + 1) * 2);

    delete[] coords;
}
#+END_SRC


Podríamos no entender el código anterior y por eso usamos Love. Los creadores de Love hacen el trabajo duro de programación y nos dejan a nosotros la parte divertida. 

** Lua 

Lua es el lenguaje de programación que usa Love. Lua es un lenguaje de programación que no está hecho por o para Love. Los creadores de Love eligieron Lua como lenguaje para su framework. 

Así, ¿qué parte de lo que programamos es Love y qué partes es Lua? Muy simple, todo lo que empieza con Love es parte del framework Love. Todo lo demás es Lua

Por ejemplo, estas funciones son parte de Love:

#+BEGIN_SRC lua
love.graphics.circle("fill", 10, 10, 100, 25)
love.graphics.rectangle("line", 200, 30, 120, 100)
#+END_SRC

Y esto es Lua: 

#+BEGIN_SRC lua
function test(a, b)
return a + b
end
print(test(10, 20))
#+END_SRC

** Cómo funciona Love 

Love llama a *3 funciones*. La primera es *love.load()* . Aquí creamos nuestras variables.

Después llamamos a *love.update() y love.draw()* repetidamente en ese orden. 

Así: love.load() -> love.update() -> love.draw() -> love.update() -> love.draw() -> love.update(), etc.

Detrás de escena, Love llama a esas funciones, y nosotros las creamos y las rellenamos con código. A esto lo llamamos *retrollamada* 

Love está hecho con *módulos*, tales como love.graphics, love.audio, love.filesystem. Hay sobre 15 módulos y cada uno de ellos está enfocado en una cosa. Todo lo que dibujas está hecho con love.graphics. Y todo lo relacionado con sonido está hecho con love.audio. 

Por ahora, nos centraremos en love.graphics.

Love tiene una [[https://www.love2d.org/wiki/Main_Page][wiki]] que explica cada una de las funciones. Si nosotros queremos dibujar un rectangulo, pues iremos en la wiki a [[https://www.love2d.org/wiki/love.graphics][love.graphics()]] y buscaremos en la página por "rectangle". Y esto es lo que encontraremos en [[https://www.love2d.org/wiki/love.graphics.rectangle][rectangle]]. 

Esta página nos dice lo que la función hace y que argumentos necesita. El primer argumento es mode, y necesita de un tipo llamado *DrawMode*. 

Nosotros podemos pinchar en [[https://www.love2d.org/wiki/DrawMode][DrawMode]] para obtener más información. 

DrawMode es una cadena que admite "fill" o "line", y controla el cómo las figuras son dibujadas.

Todos los argumentos siguientes son números. 

Así si queremos dibujar un rectángulo relleno, hacemos lo siguiente:

#+BEGIN_SRC lua
  function love.draw()
    love.graphics.rectangle("fill", 100, 200, 50, 80)
  end
#+END_SRC

Ahora si ejecutamos el juego, podremos ver un rectángulo relleno


* Moviendo un rectángulo 

Ahora podemos empezar con la parte que a mí me gusta llamar "la parte divertida". Vamos a hacer que se mueva. 

Empecemos con las 3 retrollamadas principales.

#+BEGIN_SRC lua
function love.load()

end

function love.update()

end

function love.draw()

end
#+END_SRC


Y ahora dibujaremos un rectángulo.

#+BEGIN_SRC lua
  function love.draw()
    love.graphics.rectangle("line", 100, 50, 200, 150)
  end 
#+END_SRC

El segundo y tercer argumento de esta función son la posición x e y. 

x significa la posición "horizontal" de la pantalla. 0 es la zona izquierda de la pantalla

y significa la posición "vertical" de la pantalla. 0 es la zona alta de la pantalla


[[./img/coordenadas.png]]


Ahora queremos mover el rectángulo. Es hora de empezar a pensar como un programador. ¿Qué es lo que exactamente necesitamos para que el rectángulo se mueva a la derecha? La posición x necesita ir 100, 101, 102, y así. Pero nosotros no podemos cambiar de 100 a 101. 100 es simplemente 100. Necesitamos tener algo que pueda cambiar en cualquier número que nosotros queramos. Eso es, una variable!

En love.load creamos una nueva variable llamada x, y reemplazamos el 100 en love.graphics.rectangle por x. 

#+BEGIN_SRC lua
    function love.load()
      x = 100
    end
    function love.draw()
      love.graphics.rectangle("line", x, 50, 200, 150)
    end
#+END_SRC

Ahora la posición x de nuestro rectángulo es le valor de x.

Ahora queremos hacer que el rectángulo se mueva. Esto lo haremos en love.update(). Cada actualización queremos incrementar x por 5. En otras palabras, x necesita ser el valor de x + 5. Y eso es exactamente lo que vamos a escribir

#+BEGIN_SRC lua
  function love.update()
    x = x + 5
  end
#+END_SRC

Ahora cuando x valga 100, cambiará x en 100 + 5. En la siguiente actualización x valdrá 105 y x cambiará a 105 + 5, etc. 

Ejecuta el juego y verás como el rectángulo se mueve


** Tiempo Delta 

Hemos conseguido mover el rectángulo, pero hay un pequeño problema. Si queremos ejecutar el juego en una computadora distinta, el rectángulo podría moverse con una velocidad distinta. Esto es porque no todas las computadoras actualizan a la misma frecuencia, y esto puede causar problemas. 

Por ejemplo, le decimos a la Computadora A que corre a 100 fps (fotogramas por segundo), y la Computadora B correo a 200 fsp. 

: 100 x 5 = 500
: 200 x 5 = 1000

Así en 1 segundo, x ha incrementado en 500 en la Computadora A, mientras que en la Computadora B lo ha hecho en 1000.

Afortunadamente, hay una solución para esto: el tiempo Delta.

Cuando en Love llamamos a love.update, le pasará un argumento. Añadirá el parámetro dt(tiempo delta) en el love.update y lo mostraremos. 

#+BEGIN_SRC lua
  function love.update(dt)
    print(dt)
    x = x + 5
  end
#+END_SRC

El tiempo Delta es el tiempo que pasa entre la previa y la actual actualización. Así en la computadora A, la cual corre a 100 fps, el tiempo delta tendrá una media de 1/100 lo cual es 0.01.

En la computadora B, el tiempo delta podría ser 1/200, lo cual es 0.005.

Así en un segundo, la computadora A actualiza 100 veces y el incremento de x es de 5 x 0.01 y la computadora B actualiza 200 veces y el incremento es de 5 x 0.005. 

: 100 x 5 * 0.01 = 5
: 200 x 5 * 0.005 = 5

Usando el tiempo Delta en nuestro rectángulo lo moveremos a la misma velocidad en todas la computadoras. 

#+BEGIN_SRC lua
  function love.update(dt)
    x = x + 5 * dt
  end
#+END_SRC

Ahora nuestro rectángulo se moverá 5 píxeles por segundo, en todas la computadoras. 

* Declaración if

Con las declaraciones if, nosotros podemos permitir que trozos de código sean ejecutadas solo cuando una condición ocurre. 

Creamos una declaración como esta: 

#+BEGIN_SRC lua
if condition then
-- code 
end 
#+END_SRC

Una condición, o declaración, es algo que puede ser verdadero o falso

Por ejemplo: 5 > 9

El > significa mayor qué. Así la declaración es que 5 es mayor que 9, lo cual es falso.

Puesto una declaración if en el código del incremento de x.

#+BEGIN_SRC lua
  function love.update(dt)
    if 5 > 9 then
      x = x + 100 * dt
    end
  end 
#+END_SRC

Cuando ejecutamos el juego veremos que el rectángulo no se mueve. Esto es porque la declaración es falsa. Si nosotros lo cambiamos por 5 < 9 (5 es menor que 9), entonces la declaración es verdadera, y el código dentro de la declaración if se ejecutará. 

Con esto, nosotros podemos por ejemplo hacer que x vaya hasta 700, y entonces hacer que se pare de mover con x < 700

#+BEGIN_SRC lua
  function love.update(dt)
    if x < 700 then
      x = x + 100 * dt
    end
  end
#+END_SRC

Si nosotros queremos comprobar si un valor es igual a otro, necesitamos usar dos signos iguales (==). 

Por ejemplo: 4 == 7

Un signo igual es para asignar, 2 signos iguales es para comparar. 

: x = 10 --Asignamos 10 a x
: x == 10 --Comparamos 10 a x

También podemos usar >= y <= si un valor es mayor o igual o menor o igual que otro.

: 10 <= 10 --verdadero, 10 igual a 10 
: 15 >= 4 --verdadero, 15 es mayor que 4


** Buleanos 

Una variable puede ser verdadera o falsa. Este tipo de variables las llamamos buleanas. 

Vamos a hacer una nueva variable llamada mover, con el valor de verdadero (true), y veremos si la variable es verdadera en nuestra declaración. 

#+BEGIN_SRC lua
  function love.load()
    x = 100
    mover = true
  end 

  function love.update(dt)
    --Recuerda usar dos signos ==
    if mover == true then 
      x = x + 100 * dt
    end
  end 
#+END_SRC

mover es verdadero, por lo tanto nuestro rectángulo se moverá. Pero decir mover == true, es redundante. Comprobamos si es verdadero que el valor de mover es verdadero. Simplemente usando mover como una condición correcta sería suficiente. 

#+BEGIN_SRC lua
  if mover then
    x = x + 100 * dt
  end
#+END_SRC

Si queremos comprobar que mover es falso, solo necesitamos poner un *not* delante de él. 

#+BEGIN_SRC lua
  if not move then
    x = x + 100 * dt
  end
#+END_SRC

Si queremos comprobar que un número no es igual a otro número, usamos el símbolo ~.[fn:1]

#+BEGIN_SRC lua
  if 4 ~= 5 then
    x = x + 100 * dt
  end
#+END_SRC

También podemos asignar verdadero o falso a una variable con una declaración.

Por ejemplo:

: mover = 6 > 3

Si comprobamos que mover es verdadero, y entonces cambiamos la variable a falso dentro de la declaración if, esto no es como si saltamos fuera de la declaración. Todo el código siguiente será igualmente ejecutado.

#+BEGIN_SRC lua
  if move then
    move = false
    print("Esto todavía se ejecutará!")
    x = x + 100 * dt
  end
#+END_SRC

** Flechas direccionales

Vamos ahora a hacer que el rectángulo se mueva si mantenemos la tecla direccional derecha presionada. Para esto usamos la función *love.keyboard.isDown* ([[https://www.love2d.org/wiki/love.keyboard.isDown][wiki]]).

Vamos a fijarnos que la de D de Down está en mayúsculas. Esto es un tipo de casing llamado camelCasing. Esto significa que empezamos con la palabra en minúscula, y entonces cada primera letra de las siguientes palabras va en mayúscula. 

Ahora le pasamos la cadena "right" como primer argumento para que compruebe que la flecha direccional derecha está presionada.


#+BEGIN_SRC lua
  if love.keyboard.isDown("right") then
    x = x + 100 * dt
  end
#+END_SRC

Así ahora cuando mantengamos pulsado el botón derecho de las flechas direccionales el rectángulo se moverá. 

También podemos *else* para decirle a nuestro juego qué hacer cuando la condición es falsa. Vamos a hacer que nuestro rectángulo se mueve a la izquierda, cuando no presionamos la tecla derecha. 

#+BEGIN_SRC lua
  if love.keyboard.isDown("right") then
    x = x + 100 * dt
  else
    x = x - 100 * dt --Aquí decrecemos el valor de x
  end
#+END_SRC

También podemos comprobar si otra declaración es verdadera, después del primer falso, con *elseif*. Haremos la prueba de comprobar si la flecha direccional derecha está presionada y si no, comprobaremos la izquierda. 

#+BEGIN_SRC lua
  if love.keyboard.isDown("right") then
    x = x + 100 * dt
  elseif love.keyboard.isDown("left") then
    x = x - 100 * dt
  end
#+END_SRC

Intentaremos hacer que el cuadrado se mueva hacia arriba y abajo también. 

** and & or 

  Con *and* podemos comprobar si múltiples declaraciones son ciertas.

#+BEGIN_SRC lua 
  if 5 < 9 and 14 > 7 then
    print("Ambas declaracione son ciertas")
  end
#+END_SRC

Con *or*, la declaración if se ejecutará si cualquiera de las declaraciones son ciertas.

#+BEGIN_SRC lua 
  if 20 < 9 or 14 > 7 or 5 == 10 then
    print("Una de esas declaraciones es ciertas")
  end
#+END_SRC



* Footnotes

[fn:1] Tilde en inglés virgulilla en español
