#+TITLE: tutorial-love2d
#+AUTHOR: Patricio Martínez 
#+DATE: <2018-04-20 vie>
#+EMAIL: maxxcan@disroot.org

* Introducción 

Este tutorial es una traducción casi literal de un tutorial de introducción de Love2D. La traducción la realizo tanto para aprender
como para que haya más documentación en español sobre este framework. 

El original está en [[http://sheepolution.com/learn/book/contents][Sheepolution]]

Este tutorial está escrito para personas sin experiencia en programación. Así que si no tienes ninguna experiencia en programación, espero que este tutorial también ayude con tu formación en ese área. 

* Instalación 

Los capítulos 2 y 3 se pueden realizar sin necesidad de instalar nada. Puedes usar [[https://repl.it/languages/lua][repl.it]] como alternativa. 

** Love 

Para instalar en todo caso Love, en nuestro ordenador tenemos que ir a [[https://www.love2d.org/][love2d.org]]. Una vez allí podemos elegir la versión que necesitemos según nuestra computadora y sistema operativo 

En mi caso uso Archlinux con lo que el framework nos lo podemos descargar directamente desde AUR con el gestor de paquetes yaourt. Tan solo tenemos que ejecutar el comando: 

: yaourt -S love 

** Editor 

Para este tutorial podemos elegir el editor o IDE que nos apetezca. Yo en mi caso usaré Emacs que además de soporte para Lua (el lenguaje de este framework) hay un pequeño modo para love2d que nos ayuda. 

El autor del artículo original recomienda *Zerobrane* que es un IDE con muchas características útiles para trabajar con Lua. Puedes descargarlo desde [[https://studio.zerobrane.com/support][aquí.]] 

Si posees Archlinux también puedes descargarlo usando *yaourt* 


Una vez tengamos abierto nuestro editor o IDE preferido lo abrimos y creamos un fichero con el siguiente código:

#+BEGIN_SRC lua
  function love.draw()
    love.graphics.print("Hola Mundo!", 100, 100)
  end 

#+END_SRC

Y lo salvamos con el nombre de *main.lua* 

* Variables 

¿Qué es a + b?

Una variable es un símbolo que apunta a un valor. Para ello tendremos que indicarle cual es el valor al que apunta. 

Si queremos saber cual es la suma de a + b entonces tendremos que asignarle valores. Para hacer esto escribimos:

: a = 5
: b = 3
: print(a + b)

-- Resultado: 8

La palabra que usemos para guardar los valores puede ser cualquiera.

: sheep = 3
: test = 20
: PANTS = 1024
: asdfghjkl = 42 

La variables son sensibles a mayúsculas y minúsculas. Esto significa que no es lo mismo la variable a que la variable A. Por ejemplo.

: sheep = 3 
: SHEEP = 10
: SHeEp = 200

Estas son 3 variables distintas

A la hora de asignar variables podemos hacer algo más que asignar valores. 

: a = 20 - 10 -- Sustracción
: b = 20 * 10 -- Multiplicación
: c = 20 / 10 -- División
: d = 20 ^ 10 -- Exponenciación 

Para los números con decimales usamos el punto. 

: a = 10.4
: b = 2.63
: c = 0.1
: pi = 3.141592

* Cadenas de texto

Una variable también puede guardar un texto.
: texto = "Hola Mundo"

Podemos conectar cadenas de caracteres usando dos puntos (..)

: nombre = "Daniel"
: edad = "22"
: texto = "Hola, mi nombre es " .. nombre .. ", y tengo la edad de " .. "años"
: print(texto)

Salida -- "Hola, mi nombre es Daniel y tengo la edad de 22 años"

** Reglas nombre variables 

Hay unas pocas reglas para nombrar a las variables. Primero de todo, la variable puede tener un número en ella, pero no al principio. 

: test8 -- Bien
: te8st -- Bien
: 8test -- Mal

El nombre de la variable tampoco puede incluir caracteres especiales tales como @#$%^&* 

Y finalmente, el nombre de la variable no puede ser una palabra clave. Una palabra clave es una palabra que el lenguaje de ordenador usa. Aquí tenemos una lista de palabras clave: 

| and    | break  | do   | else     | elseif |
| end    | false  | for  | function | if     |
| in     | local  | nil  | not      | or     |
| repeat | return | then | true     | until  |
| while  |        |      |          |        |


* Funciones 

Con las funciones nosotros guardamos trozos de código. Esto nos permite ejecutar este código en donde nosotros queramos. 

Hay dos formas de crear una función: 

#+BEGIN_SRC lua
  ejemplo = function ()
    print("Hola Mundo!")
  end
#+END_SRC

Y la forma más común:

#+BEGIN_SRC lua
  function ejemplo()
    print("Hola Mundo!")
  end
#+END_SRC

Primero empezamos usando la palabra clave *function*, seguido del nombre de la función. Una función es un tipo de varialbe, así que las mismas reglas que aplicamos cuando nombramos uan variable se aplica para las unciones. Después del nombre ponemos unos paréntesis. Ahora podemos empezar a escribgir el código que queremos poner dentro de la función. 

Una vez hecho esto, tenemos que escribir el nombre de la función para obtener el resultado. Esto es lo que llamamos *llamada a una función* 

** Parámetros 

Veamos el siguiente código 

#+BEGIN_SRC lua
  function ejemplo(num)
    print("Me gusta el número " .. num)
  end 
#+END_SRC

: ejemplo(15)
: ejemplo(2)
: ejemplo(100)

: -- Salida:
: -- "Me gusta el número 15"
: -- "Me gusta el número 2"
: -- "Me gusta el número 100"

Dentro del paréntesis de la función nosotros podmeos poner lo que llamamos *parámetros*. Los parámetros son variables temporales que solo existen dentro de la función. En este caso usamos el parámetro num. Ahora podemos usar num como cualquier otra variable.

** Return 

Las funciones puede devolver un valor, el cual podemos guardarlo en una variable, por ejemplo. Podemos devolver un valor usando la palabra clave *return* 

#+BEGIN_SRC lua
  function dameCinco()
    return 5
  end

a = dameCinco()
print(a)

#+END_SRC

: -- Salida: 5

Vemos el valor que devuelve dameCinco gracias a *return* 

Otro ejemplo: 

#+BEGIN_SRC lua
  -- Múltiples argumentos y parámetros separados por comas
  function sum(a, b)
    return a + b
  end

  print(sum(200, 95))
#+END_SRC

: -- Salida:
: -- 34
: -- 295

Nuestra función sum devuelve la suma de a y de b.

** ¿Por qué las funciones?

Usando funciones nosotros no tenemos que repetir cierto código una y otra vez de nuevo. Podemos simplemente hacer llamadas a la función que necesitemos. Esto es grande, porque nosotros podemos cambiar una función en el futuro, y no tener la necesidad de tener que cambiarla en todas los lugares donde la hemos puesto. 
